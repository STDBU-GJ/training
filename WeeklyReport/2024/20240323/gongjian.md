# 选拔赛2翻译
## F - Minimal Height Tree （最小高度树）
Monocarp 有一棵树，由 n 个顶点组成，扎根于 1 个顶点。他决定研究BFS（广度优先搜索），所以他在他的树上运行BFS，从根开始。BFS 可以用以下伪代码来描述：
```c++
a = [] # 处理顶点的顺序
q = Queue（）
q.put（1） # 将根放在队列的末尾
while not q.empty（）：
    k = q.pop（） # 从队列中检索第一个顶点
    a.append（k） # 将 k 追加到访问顶点的序列的末尾
    for y in g[k]：# g[k] 是顶点 k 的所有子项的列表，按升序排序
        q.put（y）

```
Monocarp 对 BFS 非常着迷，以至于最终他失去了这棵树。幸运的是，他仍然有一个顶点序列，BFS 算法（伪代码中的数组 a）访问顶点的顺序。Monocarp 知道每个顶点只被访问过一次（因为它们被放置和从队列中取出恰好一次）。此外，他知道每个顶点的所有子项都是按升序查看的。
Monocarp 知道有许多树（在一般情况下）具有相同的访问顺序 a，所以他不希望恢复他的树。Monocarp 可以与任何具有最小高度的树搭配使用。
树的高度是树顶点的最大深度，顶点的深度是从根到它的路径中的边数。例如，顶点 1 的深度是 0，因为它是根，并且所有根的子项的深度都是 1。
帮助 Monocarp 找到任何具有给定访问顺序的树和最小高度。

### 输入 
第一行包含单个整数 t（1≤t≤1000） — 测试用例的数量。
每个测试用例的第一行包含一个整数 n（2≤n≤2⋅105） — 树中的顶点数。
每个测试用例的第二行包含 n整数 a1，a2,...,an （1≤ai≤n; ai≠aj; a1=1） — BFS 算法访问顶点的顺序。
可以保证 n 的总和超过测试用例不超过 2⋅105。

### 输出
对于每个测试用例，使用给定的访问顺序打印树的最小可能高度。

### 注意 
在第一个测试用例中，只有一棵树具有给定的访问顺序：
在第二个测试用例中，也只有一棵树具有给定的访问顺序：
在第三个测试用例中，具有给定访问顺序的最优树如下所示：
## 问题E
给定一个整数N，找到满足以下所有条件的最小整数X。
X大于或等于N。
存在一对非负整数(a,b)使得X=a^3+a^2b+ab^2+b^3。
N是一个整数。
0≤N≤10^18

###输入
9

###产出
15

###
对于任意整数X，如果9≤X≤14，则没有满足题目条件的(a,b)。
对于X=15,(a,b)=(2,1)满足条件。

## G题---主教2  
## 问题陈述  
我们有一个N×N棋盘。让（i，j)表示该处的正方形从顶部数第i行和该板左侧的第j列。
该板的描述为N字符串Si这j字符串的第1个字符，Si，Sij，意味着以下内容。
如果Si,j=.,正方形（i，j )是空的。如果Si,j​=#,正方形（i,j)被白色棋子占据，
无法移动或移除。我们在广场上放置了一位白色主教（Ax,Ay)到（Bx,By)求将这位主教移出所需的最少步数 

## H题---厨师Monocarp  
厨师Monocarp刚刚把N道菜放进烤箱。他知道第i道菜的最佳烹饪时间等于Ti分钟。
在任何正整数分钟t，单尾鱼最多只能从烤箱里放出一道菜。如果第i个盘子在某一分钟t被端出来，
那么它的不愉快值是|T-ti|，T和ti之问的绝对差值。这道菜一旦出炉，就不能再放进去了。
所有的菜都要从烤箱里拿出来。单鲤能获得的最小总不愉快价值是多少？  
### 输入  
第一行包含单个整数q(1≤q≤200）-测试用例的数量。然后是q个测试用例。
测试用例的第一行包含一个整数n (1≤n＜200），即烤箱中的盘子数量。
测试用例的第二行包含n个整数t1，t2，....tn (1≤ti≤n）一每道菜的最佳烹饪时间。
所有Q个测试用例的n的总和不超过200。  
### 输出  
为每个测试用例打印一个整数一一当他把所有的菜从烤箱里拿出来时，Monocarp可以获得的最小的令人不愉快的总值。
请记住，单鱼只能在正整数分钟时放出盛子，并且在任何一分钟都不能超过一个盘子。 
## 本周：
###
主要学习和做了dfs和bfs的题目，对dfs和bfs的理解更加深入。 
其中的D题和G题印象深刻 

## 下周：
###
计划总结dfs和dfs两种题目的解题方法，解决一些比赛题目。学习一下并查集。 
